//go:build ignore
// +build ignore

package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

const filePath = "../props.go"

func main() {
	var typeFlag string
	flag.StringVar(&typeFlag, "type", "", "type name to set aliases with as type param")
	flag.Parse()

	if typeFlag == "" || filePath == "" {
		panic("Both type and path parameters must be provided")
	}

	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filePath, nil, parser.ParseComments)
	if err != nil {
		panic(err)
	}

	packageName := node.Name.Name

	var functions []string

	for _, decl := range node.Decls {
		if fn, ok := decl.(*ast.FuncDecl); ok {
			// Check if the function return type is of the desired type
			if fn.Type.Results != nil && len(fn.Type.Results.List) > 0 {
				returnType := fn.Type.Results.List[0].Type
				if isMatchingType(returnType) {
					functions = append(functions, fn.Name.Name)
				}
			}
		}
	}

	cwd, err := os.Getwd()
	if err != nil {
		panic(err)
	}
	outputFilePath := filepath.Join(cwd, "generated_optaliase.go")
	f, err := os.Create(outputFilePath)
	if err != nil {
		panic(err)
	}

	var b strings.Builder
	mustWrite(&b, "// Code generated by \"optaliase_generator.go %s\"; DO NOT EDIT.\n", strings.Join(os.Args[1:], " "))
	mustWrite(&b, "\n")
	mustWrite(&b, "package %s", currPackageName())
	mustWrite(&b, "\n")
	mustWrite(&b, "var (\n")
	for _, function := range functions {
		mustWrite(&b, "  %s = %s.%s[*%s]\n", function, packageName, function, typeFlag)
	}
	mustWrite(&b, ")")

	if _, err = f.WriteString(b.String()); err != nil {
		panic(err)
	}

	if err = f.Close(); err != nil {
		panic(err)
	}

	runGoImports(outputFilePath)
}

// panics at any error
func runGoImports(filePath string) {
	cmd := exec.Command("goimports", "-w", filePath) // -w flag writes the result back to the file
	if err := cmd.Run(); err != nil {
		panic(err)
	}
}

func mustWrite(b *strings.Builder, f string, a ...any) {
	if _, err := b.WriteString(fmt.Sprintf(f, a...)); err != nil {
		panic(err)
	}
}

// checks if the type is `*Option`
func isMatchingType(typ ast.Expr) bool {
	// Handle pointer types
	if indexExpr, ok := typ.(*ast.IndexExpr); ok {
		if ident, ok := indexExpr.X.(*ast.Ident); ok {
			if ident.Name == "Option" {
				return true
			}
		}
	}
	return false
}

// will panic at any error
func currPackageName() string {
	currentDir, err := os.Getwd()
	if err != nil {
		panic(err)
	}

	goFiles, err := filepath.Glob(filepath.Join(currentDir, "*.go"))
	if err != nil || len(goFiles) == 0 {
		panic(err)
	}

	var firstGoFile string
	for _, goFile := range goFiles {
		if filepath.Base(goFile) != "generated_optaliase.go" {
			firstGoFile = goFile
			break
		}
	}
	if firstGoFile == "" {
		panic("no files found in cwd")
	}

	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, firstGoFile, nil, parser.PackageClauseOnly)
	if err != nil {
		panic(err)
	}

	return node.Name.Name
}
